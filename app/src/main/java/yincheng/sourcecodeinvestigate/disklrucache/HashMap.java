package yincheng.sourcecodeinvestigate.disklrucache;

/**
 * Created by yincheng on 2018/5/7/17:20.
 * github:luoyincheng
 */
public class HashMap {
    /**
     * ## HashMap中的链表中的Node是Map(Node<K,V> implements Map.Entry<K,V>)
     *
     * 1.HashMap由数组和单链表组成，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入到单链表中
     * 2.HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap
     * 性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量
     * （从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的
     * 一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。
     * 3.如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，
     * 那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，
     * 则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下是无需修改的。另外，无论指定的容量为多少，构造
     * 方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方
     * 4.key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果
     * key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值
     * 对的key与目标key相等，有就返回对应的value，没有则返回null。
     */
}
